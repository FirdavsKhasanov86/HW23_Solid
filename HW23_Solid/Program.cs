using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using System.Linq;
using HW23_Solid.SingleResponsibilityPrinciple;
using HW23_Solid.OpenClosedPrinciple;
using HW23_Solid.LiskovSubstitutionPrinciple;
using HW23_Solid.InterfaceSegregationPrinciple;
using HW23_Solid.DependencyInversionPrinciple;

namespace HW23_Solid
{
    class Program
    {
        static void Main(string[] args)
        {
            // 1.Single Responsibility Principle - принцип единой ответственности.

            //Если в будущем мы захотим добавить нового сотрудника согласно SRP, один класс должен взять на себя ответственность, поэтому мы должны написать отдельный класс для генерации отчетов:

            //  Employee empl = new Employee();
            //  empl.Add();
            //  EmployeeReport emRep = new EmployeeReport();
            //  emRep.GenerateReport();


            //---------------------------------------------------------------------//

            //2.Open Closed Principle - обозначает принцип открытости/закрытости.
            //Главной концепцией данного принципа является то, что класс должен быть открыт для расширений, но закрыт от модификаций. 

            //Cогласно принципу OCP, наш класс должен быть закрыт от модификаций и открыт для расширений.
            //Если мы захотим добавить новый тип отчета, просто создайте новый класс и унаследуйте его от IEmployeeReport. Таким образом, класс IEmployeeReport закрыт от модификаций, но доступен для расширений пример которого приведен в классе OCP.

            //---------------------------------------------------------------------//

            //3.Liskov Substitution Principle - принцип подстановки Лисков, описывающий возможности заменяемости экземпляров объектов.
            //Данный принцип гласит, что мы должны иметь возможность использовать любой производный класс вместо родительского класса и вести себя с ним таким же образом без внесения изменений.

            //List<Employee> list = new List<Employee>();

            //list.Add(new JuniorEmployee());
            //list.Add(new SeniorEmployee());

            //foreach (Employee emp in list)
            //{
            //    emp.GetEmployeeDetails(985);
            //}

            //Для того чтобы не  нарушит принцип LSP. Для решения этой проблемы в C# необходимо просто разбить функционал на два интерфейса IWork и IEmployee как показоно в классе LSP.

            //--------------------------------------------------------------------------//

            //4.Interface Segregation Principle - принцип разделения интерйесов
            //Принцип разделения интерфейсов гласит, что клиенты не должны принудительно внедрять интерфейсы, которые они не используют.
            //Педположим, что есть одна база данных для хранения данных всех типов сотрудников (то есть Junior и Senior) и  все классы Employee наследуют этот интерфейс для сохранения данных. Если в будущем нам скажут, что мы хотят читать данные только для сотрудников в должности senior и решение этой задачи будет предачи ответственность другому интерфейсу как показано в классе ISP.Теперь класс JuniorEmployee будет реализовывать только интерфейс IOperationAdd, а SeniorEmployee оба интерфейса. Таким образом обеспечивается разделение интерфейсов.

            //---------------------------------------------------------------------------------//

            //5.Dependency Inversion Principle - принцип инверсии зависимостей.
            //Данный принцип гласит, что, во-первых, классы высокого уровня не должны зависеть от низкоуровневых классов. При этом оба должны зависеть от абстракций. Во-вторых, абстракции не должны зависеть от деталей, но детали должны зависеть от абстракций.
           // Как показано в классе Notification (см.класс DIP) все еще зависит от класса Email, т.к.использует его объект в конструкторе.В данном случае мы можем использовать принцип внедрения зависимостей.

        }
    }


}
